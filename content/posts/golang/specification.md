---
title: "Go工程化"
date: 2020-12-30T15:28:29+08:00
draft: true
toc: false
images:
tags: 
  - golang
---

## Go工程化

### 目录

<img src="/Users/jiangweizhao/Library/Application Support/typora-user-images/image-20201230153304375.png" alt="image-20201230153304375" style="zoom:33%;" />

app 目录下有 api、cmd、configs、internal 目录，目录里一般还会放置 README、CHANGELOG、OWNERS。

- *internal:* 是为了避免有同业务下有人跨目录引用了内部的 *biz*、*data*、*service* 等内部 *struct*。

- - *biz:* 业务逻辑的组装层，类似 *DDD* 的 *domain* 层，*data* 类似 *DDD* 的 *repo*，*repo* 接口在这里定义，使用依赖倒置的原则。
  - *data:* 业务数据访问，包含 *cache*、*db* 等封装，实现了 *biz* 的 *repo* 接口。我们可能会把 *data* 与 *dao* 混淆在一起，*data* 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 *DDD* 的 *infra*层。
  - *service:* 实现了 *api* 定义的服务层，类似 *DDD* 的 *application* 层，处理 *DTO* 到 *biz* 领域实体的转换*(DTO -> DO)*，同时协同各类 *biz* 交互，但是不应处理复杂逻辑。

*PO(Persistent Object):* 持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么数据表中的每个字段（或若干个）就对应 *PO* 的一个（或若干个）属性。

ORM推荐用这个 *https://github.com/facebook/ent*



### 依赖注入

https://github.com/google/wire

**本来我接受各种参数来构造一个对象，现在只接受一个参数——已经实例化的对象。**

也就是说我对对象的『依赖』是注入进来的，而和它的构造方式解耦了。构造它这个『控制』操作也交给了第三方，也就是控制反转。

好处：1. 方便测试 2. 单词初始化和复用 

### 依赖倒置

是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

### gRPC

- 服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。
- 负载无关的：不同的服务需要使用不同的消息类型和编码，例如 *protocol buffers*、*JSON*、*XML*和*Thrift*。
- 流*: Streaming API*。
- 阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。
- 元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。
- 标准化状态码：客户端通常以有限的方式响应 *API* 调用返回的错误。



#### 向后兼容(非破坏性)的修改

- 给 API 服务定义添加 API 接口

  从协议的角度来看，这始终是安全的。

- 给请求消息添加字段

  只要客户端在新版和旧版中对该字段的处理不保持一致，添加请求字段就是兼容的。

- 给响应消息添加字段

  在不改变其他响应字段的行为的前提下，非资源（例如，*ListBooksResponse*）的响应消息可以扩展而不必破坏客户端的兼容性。即使会引入冗余，先前在响应中填充的任何字段应继续使用相同的语义填充。

#### 向后不兼容(破坏性)的修改

- 删除或重命名服务，字段，方法或枚举值

  从根本上说，如果客户端代码可以引用某些东西，那么删除或重命名它都是不兼容的变化，这时必须修改*major* 版本号。 

- 修改字段的类型

  即使新类型是传输格式兼容的，这也可能会导致客户端库生成的代码发生变化，因此必须增加*major*版本号。 对于编译型静态语言来说，会容易引入编译错误。

- 修改现有请求的可见行为

  客户端通常依赖于 *API* 行为和语义，即使这样的行为没有被明确支持或记录。 因此，在大多数情况下，修改 *API* 数据的行为或语义将被消费者视为是破坏性的。如果行为没有加密隐藏，您应该假设用户已经发现它，并将依赖于它。 

- 给资源消息添加 读取/写入 字段

### **API Errors**

使用一小组标准错误配合大量资源

- 例如，服务器没有定义不同类型的*“*找不到*”*错误，而是使用一个标准 *google.rpc.Code.NOT_FOUND* 错误代码并告诉客户端找不到哪个特定资源。状态空间变小降低了文档的复杂性，在客户端库中提供了更好的惯用映射，并降低了客户端的逻辑复杂性，同时不限制是否包含可操作信息*(*[*/google/rpc/error_details*](https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto)*)*。

错误传播

如果您的 *API* 服务依赖于其他服务，则不应盲目地将这些服务的错误传播到您的客户端。在翻译错误时，我们建议执行以下操作：

- 隐藏实现详细信息和机密信息。
- 调整负责该错误的一方。例如，从另一个服务接收 *INVALID_ARGUMENT* 错误的服务器应该将 *INTERNAL* 传播给它自己的调用者。

### Configuration

- 环境变量(配置)

  *Region*、*Zone*、*Cluster*、*Environment*、*Color*、*Discovery*、*AppID*、*Host*，等之类的环境信息，都是通过在线运行时平台打入到容器或者物理机，供 *kit* 库读取使用。

- 静态配置

  资源需要初始化的配置信息，比如 *http/gRPC server*、*redis*、*mysql* 等，这类资源在线变更配置的风险非常大，我通常不鼓励 *on-the-fly* 变更，很可能会导致业务出现不可预期的事故，变更静态配置和发布 *bianry app* 没有区别，应该走一次迭代发布的流程。

- 动态配置

  应用程序可能需要一些在线的开关，来控制业务的一些简单策略，会频繁的调整和使用，我们把这类是基础类型*(int, bool)*等配置，用于可以动态变更业务流的收归一起，同时可以考虑结合类似 *https://pkg.go.dev/expvar* 来结合使用。

- 全局配置

  通常，我们依赖的各类组件、中间件都有大量的默认配置或者指定配置，在各个项目里大量拷贝复制，容易出现意外，所以我们使用全局配置模板来定制化常用的组件，然后再特化的应用里进行局部替换。

#### 配置工具的实践

- 语义验证
- 高亮
- Lint
- 格式化

**YAML + Protobuf**

